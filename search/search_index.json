{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ergocub Cartesian Control","text":"<p>A collection of controllers for the ergoCub and the R1 (R1SN003) robot.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#docker","title":"Docker","text":"<pre><code>docker build -t hsp/ergocub-cartesian-control:latest .\n</code></pre>"},{"location":"#source","title":"Source","text":"<p>We recommend installing the libraries directly on the robot because the control motion may be sensitive to internet lag.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li><code>robotology-superbuild</code> latest build</li> <li>You can also install them with the provided conda environment <code>environment.yml</code></li> </ul>"},{"location":"#instructions","title":"Instructions","text":"<p>We recommend installing the repository in the superbuild install directory, but of course you can choose based on your needs</p> <pre><code>git clone https://github.com/hsp-iit/ergocub-cartesian-control.git\ncd ergocub-cartesian-control\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_INSTALL_PREFIX=&lt;your-path-to-robotology-superbuild&gt;/build/install\nmake install\n</code></pre>"},{"location":"#use-this-project","title":"Use this project","text":"<p>This project provides two executables, <code>r1-cartesian-control</code> and <code>ergocub-cartesian-control</code> that directly control the robot arm. You should use <code>r1-cartesian-control</code> for R1 and <code>ergocub-cartesian-control</code> for ergoCub. More details regarding how to use the controllers can be found in Control Interface</p>"},{"location":"#cmake","title":"CMake","text":"<p>This project provides CMake configuration files that allow easy integration into other CMake-based projects. After installation, you can use <code>find_package()</code> to locate and link against the provided libraries.</p>"},{"location":"#basic-integration","title":"Basic Integration","text":"<p>To use this project in your CMake-based project, add the following to your <code>CMakeLists.txt</code>:</p> <pre><code>find_package(ergocub-cartesian-control REQUIRED)\n\n# Link against specific components\ntarget_link_libraries(your_target \n    ergocub-cartesian-control::utils\n    ergocub-cartesian-control::cub-joint-control\n    ergocub-cartesian-control::trajectory-generator\n)\n</code></pre>"},{"location":"#available-components","title":"Available Components","text":"<p>The project provides the following CMake components that can be used independently:</p> <ul> <li><code>utils</code>: Utility functions and helper classes</li> <li><code>cub-joint-control</code>: Joint position control for iCub, ergoCub and R1 robots</li> <li><code>trajectory-generator</code>: Library for generating robot trajectories</li> <li><code>gb-ergocub-cartesian-service</code>: Thrift interface definitions for the controllers</li> </ul>"},{"location":"#component-based-usage","title":"Component-based Usage","text":"<p>You can specify only the components you need:</p> <pre><code>find_package(ergocub-cartesian-control REQUIRED COMPONENTS utils trajectory-generator)\n\ntarget_link_libraries(your_target \n    ergocub-cartesian-control::utils\n    ergocub-cartesian-control::trajectory-generator\n)\n</code></pre>"},{"location":"#dependencies_1","title":"Dependencies","text":"<p>The project automatically handles its dependencies when found via CMake: - YARP (dev, os, sig components) - Eigen3</p> <p>Make sure these dependencies are available in your system or specify their paths if installed in non-standard locations.</p>"},{"location":"#example-integration","title":"Example Integration","text":"<p>Here's a complete example of how to integrate this project into your CMake project:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\nproject(my_robot_project)\n\n# Find the ergocub-cartesian-control package\nfind_package(ergocub-cartesian-control REQUIRED COMPONENTS utils cub-joint-control)\n\n# Create your executable\nadd_executable(my_robot_app src/main.cpp)\n\n# Link against the required components\ntarget_link_libraries(my_robot_app \n    ergocub-cartesian-control::utils\n    ergocub-cartesian-control::cub-joint-control\n)\n</code></pre>"},{"location":"#installation-path-configuration","title":"Installation Path Configuration","text":"<p>If you installed the project to a custom location, you may need to help CMake find it:</p> <pre><code># Option 1: Set CMAKE_PREFIX_PATH\nset(CMAKE_PREFIX_PATH \"/path/to/your/install/prefix\" ${CMAKE_PREFIX_PATH})\nfind_package(ergocub-cartesian-control REQUIRED)\n\n# Option 2: Set the package-specific path\nset(ergocub-cartesian-control_DIR \"/path/to/your/install/prefix/lib/cmake/ergocub-cartesian-control\")\nfind_package(ergocub-cartesian-control REQUIRED)\n</code></pre>"},{"location":"ControlInterface/","title":"Control Interface","text":"<p>This document describes how to use the cartesian controllers provided by this project. The controllers allow you to command the robot arms to reach desired poses in Cartesian space using high-level commands.</p>"},{"location":"ControlInterface/#overview","title":"Overview","text":"<p>The project provides two main executables:</p> <ul> <li><code>ergocub-cartesian-control</code>: For controlling ergoCub robots</li> <li><code>r1-cartesian-control</code>: For controlling R1 (R1SN003)</li> </ul> <p>Both controllers provide the same interface through YARP RPC commands and implement a Thrift service for easy integration.</p>"},{"location":"ControlInterface/#starting-the-controllers","title":"Starting the Controllers","text":"<p>The user can start the controllers using the provided configurations</p>"},{"location":"ControlInterface/#ergocub-controller","title":"ergoCub Controller","text":"<pre><code># For right arm\nergocub-cartesian-control --from config_right.ini\n\n# For left arm  \nergocub-cartesian-control --from config_left.ini\n\n# For simulation (right arm)\nergocub-cartesian-control --from config_right_sim.ini\n\n# For arms without torso control\nergocub-cartesian-control --from config_right_no_torso.ini\n</code></pre>"},{"location":"ControlInterface/#r1-controller","title":"R1 Controller","text":"<pre><code># For right arm\nr1-cartesian-control --from config_right.ini\n\n# For left arm\nr1-cartesian-control --from config_left.ini\n\n# For simulation (right_arm)\nr1-cartesian-control --from config_right_sim_r1.ini\n</code></pre>"},{"location":"ControlInterface/#rpc-interface","title":"RPC Interface","text":"<p>The controllers expose an RPC interface for sending commands. You can connect to the RPC port and send commands directly.</p>"},{"location":"ControlInterface/#connecting-to-the-controller","title":"Connecting to the Controller","text":"<pre><code># Connect to the controller's RPC port\nyarp rpc /gb-ergocub-cartesian-control/right_arm/rpc:i\n</code></pre>"},{"location":"ControlInterface/#available-commands","title":"Available Commands","text":""},{"location":"ControlInterface/#1-go-to-pose","title":"1. Go to Pose","text":"<p>Move the end-effector to a specific pose (position + orientation):</p> <pre><code>go_to_pose &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;qx&gt; &lt;qy&gt; &lt;qz&gt; &lt;qw&gt; &lt;duration&gt;\n</code></pre> <ul> <li><code>x, y, z</code>: Target position in meters (relative to robot's base frame)</li> <li><code>qx, qy, qz, qw</code>: Target orientation as quaternion</li> <li><code>duration</code>: Trajectory duration in seconds</li> </ul> <p>Example: <pre><code>go_to_pose 0.3 -0.2 0.1 0.0 0.0 0.0 1.0 5.0\n</code></pre></p>"},{"location":"ControlInterface/#2-go-to-position","title":"2. Go to Position","text":"<p>Move the end-effector to a specific position (keeping current orientation):</p> <pre><code>go_to_position &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;duration&gt;\n</code></pre> <p>Example: <pre><code>go_to_position 0.4 -0.15 0.2 3.0\n</code></pre></p>"},{"location":"ControlInterface/#3-rotate-around-axis","title":"3. Rotate Around Axis","text":"<p>Rotate the end-effector around a specified axis:</p> <pre><code>rotate_rad &lt;angle&gt; &lt;axis_x&gt; &lt;axis_y&gt; &lt;axis_z&gt; &lt;duration&gt;\nrotate_deg &lt;angle&gt; &lt;axis_x&gt; &lt;axis_y&gt; &lt;axis_z&gt; &lt;duration&gt;\n</code></pre> <ul> <li><code>angle</code>: Rotation angle (radians for <code>rotate_rad</code>, degrees for <code>rotate_deg</code>)</li> <li><code>axis_x, axis_y, axis_z</code>: Rotation axis (unit vector)</li> </ul> <p>Example: <pre><code>rotate_deg 45.0 0.0 0.0 1.0 4.0  # Rotate 45\u00b0 around Z-axis\n</code></pre></p>"},{"location":"ControlInterface/#4-go-home","title":"4. Go Home","text":"<p>Return to the predefined home position:</p> <pre><code>go_home\n</code></pre>"},{"location":"ControlInterface/#5-get-current-pose","title":"5. Get Current Pose","text":"<p>Retrieve the current end-effector pose:</p> <pre><code>get_pose\n</code></pre> <p>Returns a 4x4 homogeneous transformation matrix.</p>"},{"location":"ControlInterface/#6-motion-status","title":"6. Motion Status","text":"<p>Check if the current motion is completed:</p> <pre><code>is_motion_done\n</code></pre> <p>Returns <code>true</code> if the motion is finished, <code>false</code> otherwise.</p>"},{"location":"ControlInterface/#7-stop-motion","title":"7. Stop Motion","text":"<p>Stop the current motion:</p> <pre><code>stop\n</code></pre>"},{"location":"ControlInterface/#8-reachability-analysis","title":"8. Reachability Analysis","text":"<p>Check if a pose is reachable by the robot:</p> <pre><code>is_pose_reachable &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;qx&gt; &lt;qy&gt; &lt;qz&gt; &lt;qw&gt;\nask_reachability_evaluation &lt;pose_matrix&gt;\nretrieve_reachable_pose\n</code></pre>"},{"location":"ControlInterface/#thrift-service-interface","title":"Thrift Service Interface","text":"<p>For programmatic access, the controllers implement a Thrift service with the same functionality. This allows easy integration from C++, Python, or other languages.</p>"},{"location":"ControlInterface/#c-example","title":"C++ Example","text":"<pre><code>#include &lt;gb-ergocub-cartesian-service/ergoCubCartesianService.h&gt;\n#include &lt;yarp/os/Network.h&gt;\n#include &lt;yarp/os/RpcClient.h&gt;\n\n// Connect to the service\nyarp::os::Network yarp;\nyarp::os::RpcClient client;\nclient.open(\"/client\");\nyarp.connect(\"/client\", \"/gb-ergocub-cartesian-control/right_arm/rpc:i\");\n\n// Create service proxy\nergoCubCartesianService service;\nservice.yarp().attachAsClient(client);\n\n// Send commands\nbool success = service.go_to_position(0.3, -0.2, 0.1, 5.0);\n</code></pre>"},{"location":"ControlInterface/#python-example","title":"Python Example","text":"<pre><code>import yarp\n\n# Initialize YARP\nyarp.Network.init()\n\n# Connect to service\nclient = yarp.RpcClient()\nclient.open(\"/python_client\")\nyarp.Network.connect(\"/python_client\", \"/gb-ergocub-cartesian-control/right_arm/rpc:i\")\n\n# Send command\ncmd = yarp.Bottle()\ncmd.addString(\"go_to_position\")\ncmd.addFloat64(0.3)\ncmd.addFloat64(-0.2) \ncmd.addFloat64(0.1)\ncmd.addFloat64(5.0)\n\nreply = yarp.Bottle()\nclient.write(cmd, reply)\n</code></pre>"},{"location":"ControlInterface/#coordinate-frames","title":"Coordinate Frames","text":"<p>The controllers work in the robot's coordinate frame. Tipically they are directed in the following way:</p> <ul> <li>X-axis: Forward direction of the robot</li> <li>Y-axis: Left direction of the robot  </li> <li>Z-axis: Upward direction</li> <li>Origin: <code>root_link</code> for ergoCub and <code>mobile_base_body_link</code> for R1</li> </ul>"},{"location":"ControlInterface/#configuration","title":"Configuration","text":""},{"location":"ControlInterface/#general-configuration-parameters","title":"General Configuration Parameters","text":""},{"location":"ControlInterface/#control-parameters","title":"Control Parameters","text":"<ul> <li><code>rate</code> (default: <code>100.0</code>): Control loop frequency in Hz. Higher values provide smoother control but require more computational resources.</li> <li><code>traj_duration</code> (default: <code>5.0</code>): Default trajectory duration in seconds when not specified in commands.</li> </ul>"},{"location":"ControlInterface/#communication","title":"Communication","text":"<ul> <li><code>rpc_local_port_name</code> (e.g: <code>/gb-ergocub-cartesian-control/right_arm/rpc:i</code>): Local YARP port name for RPC communication with the controller.</li> </ul>"},{"location":"ControlInterface/#convergence-and-limits","title":"Convergence and Limits","text":"<ul> <li><code>position_error_th</code> (default: <code>0.0005</code>): Position convergence threshold in meters. The controller considers a motion complete when the position error is below this value.</li> <li><code>max_iteration</code> (default: <code>10000</code>): Maximum number of iterations for the inverse kinematics solver before giving up.</li> </ul>"},{"location":"ControlInterface/#debugging-and-logging","title":"Debugging and Logging","text":"<ul> <li><code>module_logging</code> (default: <code>true</code>): Enable data logging for analysis and debugging.</li> <li><code>module_verbose</code> (default: <code>true</code>): Enable verbose console output for debugging purposes.</li> <li><code>qp_verbose</code> (default: <code>false</code>): Enable verbose console output for the QP solver.</li> </ul>"},{"location":"ControlInterface/#arm-section-parameters","title":"ARM Section Parameters","text":""},{"location":"ControlInterface/#robot-configuration","title":"Robot Configuration","text":"<ul> <li><code>name</code> (example: <code>left_arm</code>, <code>right_arm</code>): Identifier name for the arm being controlled.</li> <li><code>joint_axes_list</code> (example: <code>(torso_yaw_joint l_shoulder_pitch l_shoulder_roll l_shoulder_yaw l_elbow l_wrist_yaw l_wrist_roll l_wrist_pitch)</code>): Complete ordered list of joint names to control. Order matters for the control algorithm.</li> <li><code>joint_ports_list</code> (example: <code>(/cer/torso /cer/left_arm)</code>): List of YARP port names for communicating with the robot's joint interfaces.</li> <li><code>joint_local_port</code> (example: <code>/r1-cartesian-control/left_arm</code>): Local YARP port prefix for this controller instance.</li> </ul>"},{"location":"ControlInterface/#ik_param-section-parameters","title":"IK_PARAM Section Parameters","text":""},{"location":"ControlInterface/#joint-limits-and-constraints","title":"Joint Limits and Constraints","text":"<ul> <li><code>limits_param</code> (default: <code>0.90</code>): Safety factor for joint limits (0 &lt; value &lt; 1). Reduces effective joint range to avoid hitting limits.</li> <li><code>max_joint_position_variation</code> (default: <code>25.0</code>): Maximum allowed joint position change per control cycle in degrees.</li> <li><code>max_joint_position_track_error</code> (default: <code>1.5</code>): Maximum acceptable tracking error between desired and actual joint positions in degrees.</li> </ul>"},{"location":"ControlInterface/#control-weights-and-gains","title":"Control Weights and Gains","text":"<ul> <li><code>joint_vel_weight</code> (default: <code>(5.0 0.0)</code>): Joint velocity cost weight and offset for the QP solver <code>(weight, offset)</code>.</li> <li><code>position_param</code> (default: <code>(20.0 0.5)</code>): Position control parameters <code>(cost_weight, proportional_gain)</code>.</li> <li><code>orientation_param</code> (default: <code>(10.0 0.5)</code>): Orientation control parameters <code>(cost_weight, proportional_gain)</code>.</li> <li><code>joint_pos_param</code> (default: <code>(2.5 10.0 5.0)</code>): Joint position control gains <code>(cost_weight, proportional_gain, derivative_gain)</code>.</li> </ul>"},{"location":"ControlInterface/#reference-configuration","title":"Reference Configuration","text":"<ul> <li><code>joint_ref</code> (example: <code>(0.0 0.0 0.1 0.0 0.1 0.0 0.0 0.0)</code>): Reference joint configuration used for null-space projection. Must match the number and order of joints in <code>joint_axes_list</code>.</li> </ul>"},{"location":"ControlInterface/#fk_param-section-parameters","title":"FK_PARAM Section Parameters","text":""},{"location":"ControlInterface/#kinematic-chain-definition","title":"Kinematic Chain Definition","text":"<ul> <li><code>root_frame_name</code> (default: <code>mobile_base_body_link</code> for R1, <code>root_link</code> for ergoCub): Name of the root frame for the kinematic chain.</li> <li><code>ee_frame_name</code> (example: <code>l_hand_palm</code>, <code>r_hand_palm</code>): Name of the end-effector frame that will be controlled.</li> </ul>"},{"location":"ControlInterface/#fsm_param-section-parameters","title":"FSM_PARAM Section Parameters","text":""},{"location":"ControlInterface/#finite-state-machine","title":"Finite State Machine","text":"<ul> <li><code>stop_speed</code> (default: <code>0.001</code>): Velocity threshold in rad/s for determining when motion has stopped (approximately 0.057 degrees/s).</li> </ul>"},{"location":"ControlInterface/#tuning-guidelines","title":"Tuning Guidelines","text":""},{"location":"ControlInterface/#performance-tuning","title":"Performance Tuning","text":"<ul> <li>Increase <code>rate</code> for smoother control, but monitor CPU usage</li> <li>Adjust <code>position_param</code> and <code>orientation_param</code> weights to balance position vs orientation tracking</li> <li>Tune <code>joint_pos_param</code> gains for better joint space control</li> </ul>"},{"location":"ControlInterface/#safety-tuning","title":"Safety Tuning","text":"<ul> <li>Reduce <code>limits_param</code> for additional safety margin from joint limits</li> <li>Lower <code>max_joint_position_variation</code> for slower, safer motions</li> <li>Decrease <code>max_joint_position_track_error</code> for stricter tracking requirements</li> </ul>"},{"location":"ControlInterface/#safety-considerations","title":"Safety Considerations","text":"<ol> <li>Joint Limits: The controllers automatically enforce joint position and velocity limits</li> <li>Collision Avoidance: No built-in collision avoidance - ensure trajectories are safe</li> <li>Emergency Stop: Use the <code>stop</code> command to halt motion immediately</li> <li>Reachability: Use reachability checks before commanding unreachable poses</li> <li>Monitoring: Monitor <code>is_motion_done</code> to ensure commands complete successfully</li> </ol>"},{"location":"ControlInterface/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ControlInterface/#common-issues","title":"Common Issues","text":"<ol> <li>Controller not responding: Check YARP network and port connections</li> <li>Motion not starting or wrong motion: Verify pose is reachable and within joint limits</li> <li>Jerky motion: Increase trajectory duration for smoother movements</li> <li>High tracking error: Tune controller gains in configuration file</li> </ol>"},{"location":"ControlInterface/#debugging","title":"Debugging","text":"<p>Enable verbose output in the configuration: <pre><code>module_verbose true\nmodule_logging true\n</code></pre></p> <p>Check controller status through RPC: <pre><code>is_motion_done\nget_pose\n</code></pre></p>"}]}